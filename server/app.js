const express = require('express')
const app = express()
const path = require('path');
const fs = require('fs');
const {MongoClient} = require('mongodb');
const bcrypt = require('bcrypt'); // Used for password hashing
const saltRounds = 10; //any number , we could fix it as 10 for simplicity
const session = require('express-session');
require('dotenv').config({
    path: '../.env'
}); // This points to the .env in the root folder
app.set('case sensitive routing', false);
const key = "eyJvaWRjUGx1Z2luU3RhdGVWZXJzaW9uIjowLCJzdGF0ZSI6W119";

const destinationPages = {
    "Bali": "bali.ejs",
    "Inca": "inca.ejs",
    "Paris": "paris.ejs",
    "Annapurna": "annapurna.ejs",
    "Rome": "rome.ejs",
    "Santorini": "santorini.ejs"
};


app.use(session({
    secret: key, // Replace with a secure key
    resave: false, // Prevents session being saved repeatedly
    saveUninitialized: true, // Saves a new session even if it is not modified
    cookie: {
        secure: false
    } // Set to true if using HTTPS
}));


// Create a MongoClient with a MongoClientOptions object to set the Stable API version
const uri = "mongodb://127.0.0.1:27017";
const client = new MongoClient(uri);
const dbName = 'myDB';  //project requirement
const collectionName = 'myCollection';
let db, usersCollection;

// Connect to MongoDB and get the users collection
async function connectDb() {
    try {
        await client.connect();
        console.log('Connected to MongoDB');
        db = client.db(dbName); // Access the database
        usersCollection = db.collection(collectionName); // Get the collection
    } catch (error) {
        console.error('Error connecting to MongoDB:', error);
    }
}

// Setup Express middleware to parse JSON request bodies
app.use(express.json());
app.use(express.urlencoded({
    extended: true
})); // For parsing form data


// Set the 'views' directory
app.set('views', path.join(__dirname, '../views'));

// Serve static files from the 'public' directory
app.use(express.static(path.join(__dirname, '../public')));

// Set the view engine to EJS as required
app.set('view engine', 'ejs');


// each routing path will be done like that it could also be done 
// in a separate routes folder if it overwhelmed us
// req is the request payload and the res is the response generated by the server

// TODO place all get to redirect to the correct locations , insure rest of routes handle ONLY the user who made a login or a registration
app.get(['/', '/login'], (req, res) => {
    res.render('login.ejs');
});

app.get('/registration', (req, res) => {
    res.render('registration.ejs');
});

app.get('/home', (req, res) => {
    if (!req.session.user) {
        return res.redirect('/login'); // Redirect to login if no session user
    }
    res.render('home.ejs'); // Render home page if session user exists
});


//POST METHODS
// Login Route (POST method to check credentials)
app.post(['/', '/login'], async (req, res) => {
    const { username, password } = req.body;
    let allowLogin = false;

    console.log("Username:", username);
    console.log("Password:", password);

    if (!username || !password) {
        return res.status(400).json({ error: "Username and password are required." });
    }

    if (username === 'admin' && password === 'admin') {
        allowLogin = true;
    }

    try {
        await connectDb();

        if (!allowLogin) {
            // Check if the user exists in the database
            const user = await usersCollection.findOne({ username });

            if (!user) {
                return res.status(401).json({ error: "User does not exist" });
            }

            // Compare the entered password with the stored hashed password
            const isMatch = await bcrypt.compare(password, user.passwordHash); // Use 'passwordHash'

            if (!isMatch) {
                return res.status(401).json({ error: "Invalid credentials." });
            }

            // Store user information in the session
            req.session.user = { username: user.username };

            return res.status(200).json({ message: "Login successful!" }); // Only one response here
        }

        // If allowLogin is true (admin login)
        req.session.user = { username: 'admin' };

        return res.status(200).json({ message: "Login successful!" }); // Only one response here
    } catch (err) {
        console.error(err);
        return res.status(500).json({ error: "Error logging in." });
    }
});

app.post('/registration', async (req, res) => {
    const { username, password } = req.body;

    if (!username || !password) {
        return res.status(400).json({ error: "Username and password are required." });
    }

    try {
        await connectDb();

        // Check if the username is already taken
        const user = await usersCollection.findOne({ username, type: "user" });
        if (user) {
            return res.status(401).json({ error: "Username is already taken. Please choose another one." });
        }

        // Hash the password
        const hashedPassword = await bcrypt.hash(password, saltRounds);

        // Save the user to the database
        const newUser = {
            type: "user", // Discriminator field
            username,
            passwordHash: hashedPassword, // Correct field name for hashed password
            wantToGoList: [] // Initialize with an empty list
        };

        const result = await usersCollection.insertOne(newUser);

        res.status(201).json({ message: "User registered successfully!" });
    } catch (err) {
        console.error(err);
        res.status(500).json({ error: "Error registering user." });
    }
});

app.post('/search', async(req,res)=>{
    const {searchKey} = req.body;
    if (!searchKey )         
        return res.status(400).json({ error: "Search key is required." });
    try{
        await connectDb();

        // searching for destinations
        const destinations = await usersCollection.find({
            type: "destination", // Only search destination documents
            name: { $regex: searchKey, $options: "i" } // Case-insensitive substring search
        }).toArray();

        if (destinations.length === 0){
            return res.status(400).json({ error: "No matching destinations found" });
        }
        res.status(200).json({ destinations });
    }
    catch{
        console.error("Error searching destinations:", err);
        res.status(500).json({ error: "Error searching destinations." });
    }
});


// Path to the JSON file
const destinationsFilePath = path.join(__dirname, 'destinations.json');

// Load destinations from the JSON file
let destinationsInFile = [];
try {
    const data = fs.readFileSync(destinationsFilePath, 'utf-8');
    destinationsInFile = JSON.parse(data);
} catch (err) {
    console.error("Error reading destinations JSON file:", err);
    process.exit(1); // Exit the process if the file can't be read
}

// Dynamically create routes for each destination
destinationsInFile.forEach(destination => {
    app.get(`/${destination.name}`, async (req, res) => {
        if (!req.session.user) {
            return res.redirect('/login'); // Redirect to login if no session user
        }
        try {
            console.log("Requested destination:", destination.name);

            if (!destination.template) {
                console.error("Missing template for destination:", destination.name);
                return res.status(500).send("Template not defined for this destination.");
            }

            res.render(destination.template, {
                videoUrl: destination.videoUrl,
                description: destination.description,
                image: destination.image,
                name: destination.name
            });
        } catch (err) {
            console.error("Error fetching destination:", err);
            res.status(500).send("Error loading the page.");
        }
    });
});


async function handleDestinationRoute(req, res, type, template) {
    if (!req.session.user) {
        return res.redirect('/login'); // Redirect to login if no session user
    }

    try {
        // Fetch destinations of the given type
        const destinations = destinationsInFile.filter(item => 
            item.type === "destination" && item.destinationType === type
        );

        if (destinations.length === 0) {
            return res.status(404).send(`No destinations found for ${type}.`);
        }

        // Render the EJS template with the fetched data
        res.render(template, { destinations, type });
    } catch (err) {
        console.error(`Error fetching destinations for ${type}:`, err);
        res.status(500).send("Error loading destinations.");
    }
}

// Routes
app.get('/cities', (req, res) => handleDestinationRoute(req, res, "City", "Cities"));
app.get('/islands', (req, res) => handleDestinationRoute(req, res, "Island", "Islands"));
app.get('/hiking', (req, res) => handleDestinationRoute(req, res, "Hiking", "Hiking"));





app.post('/add-to-want-to-go', async (req, res) => {
    const { destinationName } = req.body;
    console.log(`add to list has been clicked for ${destinationName}`); 
    if (!req.session.user) {
        return res.redirect('/login'); // Redirect to login if no session user
    }

    try {
        await connectDb();

        // Find the logged-in user
        const user = await usersCollection.findOne({ username: req.session.user.username });

        if (!user) {
            return res.status(404).json({ error: "User not found." });
        }

        // Check if the destination is already in the list
        if (user.wantToGoList.includes(destinationName)) {
            return res.status(400).json({ error: "Destination already in Want-to-Go List." });
        }

        // Add the destination to the list
        await usersCollection.updateOne(
            { username: req.session.user.username },
            { $push: { wantToGoList: destinationName } }
        );

        res.status(200).json({ message: "Destination added to Want-to-Go List." });
    } catch (err) {
        console.error("Error updating Want-to-Go List:", err);
        res.status(500).json({ error: "Error updating Want-to-Go List." });
    }
});


app.get('/wanttogo', async (req, res)=>{
    if (!req.session.user) {
        return res.redirect('/login'); // Redirect to login if no session user
    }
    
    const username1 = req.session.user.username;
    
    try{
        await connectDb();

        const user = await usersCollection.findOne(
            { username: username1 }, // Filter
            { projection: { wantToGoList: 1 } } // Projection
        );

        if (!user) {
            console.error(`No user found with username: ${username1}`);
            return;
        }

        console.log("User Document:", user);        

        //destination-names stored in the database
        const destinations = user.wantToGoList;
            
        if (!destinations || !Array.isArray(destinations) || destinations.length === 0) {
            console.error("wantToGoList is empty or not an array.");
            // Handle the empty list as needed
            res.status(400).json({ message: "No destinations yet , please add some destinations to your want to go list " });
            return;
        }
        const data = destinationsInFile.filter(item => 
            item.type === "destination" && destinations.includes(item.name)
        );
        res.status(200).json({ data });
    }catch{
        return res.status(500).json({ error: "internal server error when fetching wanttogo list" });   
    }
});


app.listen(3000, () => {
    console.log('Server started on port 3000');
});


app.get('*', (req, res) => {            
    res.status(404).render('404', { url: req.originalUrl });
});